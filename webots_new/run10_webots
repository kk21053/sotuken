#!/usr/bin/env python3
"""run10_webots

「各脚にランダムな環境を設置して run_webots を起動」を指定回数（既定10回）繰り返す。

- 1回ごとに FL/FR/RL/RR へランダムに環境ラベルを割り当てる
- その割り当てを引数として `run_webots` を起動（run_webots 側が set_environment を実行）
- 実行条件（seed・割り当て）を JSON に保存する

注意:
- Webots は通常、ユーザがウィンドウを閉じるまで戻らないため、各回の終了は手動操作になる。
"""

from __future__ import annotations

import argparse
import json
import os
import random
import subprocess
import sys
import time
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional

ROOT = Path(__file__).resolve().parent
RUN_WEBOTS = ROOT / "run_webots"

LEG_IDS = ["FL", "FR", "RL", "RR"]
DEFAULT_ENVIRONMENTS = ["NONE", "BURIED", "TRAPPED", "TANGLED", "MALFUNCTION"]


def _now_iso() -> str:
    return datetime.now().astimezone().isoformat(timespec="seconds")


def _validate_env_list(values: List[str]) -> List[str]:
    envs = [v.strip().upper() for v in values if v.strip()]
    unknown = sorted({e for e in envs if e not in DEFAULT_ENVIRONMENTS})
    if unknown:
        raise ValueError(
            "無効な環境が含まれています: "
            + ", ".join(unknown)
            + "（有効: "
            + ", ".join(DEFAULT_ENVIRONMENTS)
            + "）"
        )
    if not envs:
        raise ValueError("環境候補が空です")
    return envs


def _default_seed() -> int:
    return int.from_bytes(os.urandom(4), "big")


@dataclass
class RunRecord:
    run_id: str
    expected: Dict[str, str]
    started_at: str
    ended_at: Optional[str] = None
    exit_code: Optional[int] = None
    elapsed_sec: Optional[float] = None
    log_path: Optional[str] = None


def main() -> None:
    parser = argparse.ArgumentParser(
        prog="run10_webots",
        description="各脚へランダム環境を設定して run_webots を複数回起動します（既定10回、既定は映像なし）",
    )
    parser.add_argument(
        "--runs",
        type=int,
        default=10,
        help="繰り返し回数（既定: 10）",
    )
    parser.add_argument(
        "--seed",
        type=int,
        default=None,
        help="乱数seed（省略時はランダム）",
    )
    parser.add_argument(
        "--envs",
        nargs="+",
        default=DEFAULT_ENVIRONMENTS,
        help="環境候補（例: --envs NONE BURIED TRAPPED）",
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="環境割り当てだけ生成して起動しない",
    )
    parser.add_argument(
        "--capture-logs",
        action="store_true",
        help="run_webots/Webots の stdout/stderr をファイルへ保存する",
    )
    parser.add_argument(
        "--continue-on-error",
        action="store_true",
        help="エラーが出ても次の回へ進む（既定は停止）",
    )

    # run_webots のオプションを透過
    parser.add_argument("--stream", action="store_true", help="run_webots の --stream を付与")
    parser.add_argument(
        "--stream-port",
        type=int,
        default=None,
        help="run_webots の --stream-port を付与",
    )
    parser.add_argument(
        "--gui",
        action="store_true",
        help="GUI/映像ありで起動する（既定は --headless 相当で映像なし）",
    )
    parser.add_argument(
        "--gui-console",
        action="store_true",
        help="run_webots の --gui-console を付与（非推奨）",
    )

    args = parser.parse_args()

    if args.runs <= 0:
        print("エラー: --runs は 1 以上で指定してください")
        sys.exit(2)

    if not RUN_WEBOTS.exists():
        print(f"エラー: run_webots が見つかりません: {RUN_WEBOTS}")
        sys.exit(2)

    try:
        env_candidates = _validate_env_list(list(args.envs))
    except ValueError as e:
        print(f"エラー: {e}")
        sys.exit(2)

    seed = args.seed if args.seed is not None else _default_seed()
    rng = random.Random(seed)

    out_dir = ROOT / "benchmarks" / "run10_webots"
    logs_dir = out_dir / "logs"
    out_dir.mkdir(parents=True, exist_ok=True)
    logs_dir.mkdir(parents=True, exist_ok=True)

    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    out_json = out_dir / f"run_{timestamp}_seed{seed}.json"

    meta = {
        "schema": "run10_webots/v1",
        "created_at": _now_iso(),
        "seed": seed,
        "runs": args.runs,
        "envs": env_candidates,
        "run_webots": str(RUN_WEBOTS),
        "dry_run": bool(args.dry_run),
        "capture_logs": bool(args.capture_logs),
        "records": [],
    }

    def flush() -> None:
        out_json.write_text(json.dumps(meta, ensure_ascii=False, indent=2) + "\n")

    flush()

    passthrough: List[str] = []

    # 既定は映像なし（headless）。明示的に --gui か --stream の場合のみ映像あり。
    headless = (not args.gui) and (not args.stream)
    if headless:
        passthrough.append("--headless")

    if args.stream:
        passthrough.append("--stream")
    if args.stream_port is not None:
        passthrough.extend(["--stream-port", str(args.stream_port)])
    if args.gui_console:
        passthrough.append("--gui-console")

    print("run10_webots を開始します")
    print("- runs:", args.runs)
    print("- seed:", seed)
    print("- envs:", ", ".join(env_candidates))
    if args.dry_run:
        print("- dry-run: 起動しません")
    if args.capture_logs:
        print("- capture-logs: 有効")
    if headless:
        print("- mode: headless（映像なし）")
    elif args.stream:
        print("- mode: stream（映像あり）")
    else:
        print("- mode: gui（映像あり）")
    if passthrough:
        print("- run_webots options:", " ".join(passthrough))
    print("- 出力:", out_json)

    for i in range(1, args.runs + 1):
        run_id = f"R{i:02d}"
        expected = {leg: rng.choice(env_candidates) for leg in LEG_IDS}
        cmd = [str(RUN_WEBOTS), *passthrough, expected["FL"], expected["FR"], expected["RL"], expected["RR"]]

        record = RunRecord(run_id=run_id, expected=expected, started_at=_now_iso())
        meta["records"].append(
            {
                "run_id": record.run_id,
                "expected": record.expected,
                "started_at": record.started_at,
                "ended_at": record.ended_at,
                "exit_code": record.exit_code,
                "elapsed_sec": record.elapsed_sec,
                "log_path": record.log_path,
            }
        )
        flush()

        print("\n============================================================")
        print(f"[{run_id}] 環境: FL={expected['FL']} FR={expected['FR']} RL={expected['RL']} RR={expected['RR']}")
        print(f"[{run_id}] 起動: {' '.join(cmd)}")

        if args.dry_run:
            continue

        t0 = time.time()
        try:
            if args.capture_logs:
                log_path = logs_dir / f"run_{timestamp}_seed{seed}_{run_id}.log"
                record.log_path = str(log_path)
                with log_path.open("w", encoding="utf-8") as f:
                    proc = subprocess.run(cmd, stdout=f, stderr=subprocess.STDOUT)
                record.exit_code = proc.returncode
            else:
                proc = subprocess.run(cmd)
                record.exit_code = proc.returncode
        except KeyboardInterrupt:
            print("\n中断されました。ここまでの結果を保存して終了します。")
            record.exit_code = 130
            record.ended_at = _now_iso()
            record.elapsed_sec = time.time() - t0
            # 直前recordの反映
            meta["records"][-1].update(
                {
                    "ended_at": record.ended_at,
                    "exit_code": record.exit_code,
                    "elapsed_sec": record.elapsed_sec,
                    "log_path": record.log_path,
                }
            )
            flush()
            sys.exit(130)
        finally:
            record.ended_at = record.ended_at or _now_iso()
            record.elapsed_sec = record.elapsed_sec or (time.time() - t0)
            meta["records"][-1].update(
                {
                    "ended_at": record.ended_at,
                    "exit_code": record.exit_code,
                    "elapsed_sec": record.elapsed_sec,
                    "log_path": record.log_path,
                }
            )
            flush()

        if record.exit_code != 0:
            print(f"[{run_id}] エラー終了: exit_code={record.exit_code}")
            if not args.continue_on_error:
                print("--continue-on-error が無いため停止します。")
                break

    print("\n完了しました。出力:", out_json)


if __name__ == "__main__":
    main()
