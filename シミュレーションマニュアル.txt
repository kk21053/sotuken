シミュレーションマニュアル（webots_new 完全網羅版）
作成日: 2026-01-25
対象: /home/kk21053/sotuken/webots_new

======================================================================
0. このマニュアルの目的と範囲
======================================================================
本書は、webots_new 内のプログラム一式（Webotsワールド・環境配置スクリプト・Spot/Droneコントローラ・診断パイプライン・Qwen(GGUF)連携・評価スクリプト）について、卒業論文に記述できるよう「実装仕様」を網羅的に説明する。

重要（検証/評価に用いるスクリプトの指定）:
- 本研究の検証（繰り返し実験）に使用するスクリプトは run10_webots と result10 のみ。
- run_webots / set_environment / controllers 以下は run10_webots の内部で呼ばれる実行要素として説明する。
- run100_webots 等も存在するが、卒論の検証対象としては run10_webots/result10 の説明を正式版とする。

======================================================================
1. ディレクトリ構成（webots_new）
======================================================================
主要ファイル:
- run10_webots                 : ランダム環境を各脚に割り当てて run_webots を10回(既定)起動する検証スクリプト
- result10                     : run10_webotsの出力JSONと診断セッションJSONLを突合してAccuracyを算出
- run_webots                   : Webots起動ラッパ（必要なら set_environment を実行してから world を起動）
- set_environment              : scenario.ini と worlds/sotuken_world.wbt を書き換え、脚ごとの環境を配置
- run100_webots                : run10_webots の100回版
- result100                    : run100_webots の集計
- result                       : 直近1セッションを簡易表示（run_webots 単発確認向け）
- replay_can_threshold.py       : 過去run10の「can閾値未達」パターンを抽出し、同パターンで再実行する補助
- qwen_gguf_demo.py             : GGUF(Qwen)を llama-cpp-python で単発推論できることを確認するデモ
- requirements_qwen_4bit.txt    : Qwen(GGUF)用の追加依存
- config/scenario.ini          : 環境設定（脚ごとのラベル）と物理パラメータ（摩擦など）
- controllers/
  - spot_self_diagnosis/spot_self_diagnosis.py
      Spot（四足）側コントローラ。6試行の小動作→自己診断値(self_can_raw)を送信。
  - drone_circular_controller/drone_circular_controller.py
      Drone（観測者）側コントローラ。Spot customData を監視し、観測を蓄積して最終診断を確定・JSONL保存。
  - diagnostics_pipeline/
      診断の中核ロジック一式。
      - __init__.py        : パッケージ初期化（モジュール解決用）
      - pipeline.py        : セッション/試行の統合、finalize、Qwen呼び出し、ログ出力
      - self_diagnosis.py  : Spot自己診断の集計（self_can_raw→spot_can）
      - drone_observer.py  : Drone観測の集計（end_disp等→drone_can/p_drone）
      - llm_client.py      : Qwen(GGUF)推論（任意）とp_qwen生成
      - rule_fusion.py     : spot_can/drone_can と分布から最終判定（仕様Step7相当）
      - fusion.py          : 分布のargmaxユーティリティ（互換/補助）
      - logger.py          : JSONLログ出力
      - models.py          : dataclass（LegState/TrialResult/SessionRecord等）
      - utils.py           : clamp/normalize/JSONL writer など
      - config.py          : 定数（試行パラメータ、閾値、ログ設定）
- worlds/sotuken_world.wbt     : Webotsワールド（Spot/Drone/障害物プロト等を含む）
- protos/                      : Webots PROTO（custom/vendor）
- benchmarks/                  : run10_webots の実験ログ（run_*.json, logs/）

ログ出力（主に評価で使用）:
- controllers/drone_circular_controller/logs/leg_diagnostics_sessions.jsonl
  1セッション（=1回のWebots実行）につき1行のJSONが追記される。
- controllers/drone_circular_controller/logs/leg_diagnostics_events.jsonl
  詳細イベントログ。既定は無効（DIAG_ENABLE_EVENT_LOG=1 で有効化）。
- controllers/drone_circular_controller/logs/qwen_batch_raw_*.txt
  Qwenの生出力を保存（DIAG_DUMP_QWEN_RAW=1 の時のみ生成される）。

======================================================================
2. 前提条件（実行環境）
======================================================================
2.1 必須
- Webots がインストール済みで、CLIコマンド webots がPATHにあること。
- Python3（Webotsが利用するPython実行環境）。

2.2 Qwen(GGUF)を使う場合の追加依存
- requirements_qwen_4bit.txt に記載:
  - llama-cpp-python>=0.3.16
  - huggingface_hub>=0.23.0

補足: Webots が system python を使う場合でも動かすため、diagnostics_pipeline/llm_client.py は
  プロジェクト内 .venv/site-packages を sys.path に追加して import を試みる実装を持つ。

2.3 GUIが出せない環境
- run_webots は --stream（Webotsのストリーミング）や --headless（描画抑制）をサポートする。
- GUI環境変数（DISPLAY/WAYLAND_DISPLAY）が無い場合は --stream を推奨。

2.4 終了制御（重要）
- Spotコントローラは既定で simulationQuit を呼ばない（SPOT_AUTO_QUIT=0）。
  これは Drone側のfinalize（Qwen推論など）が長い場合に、Spotが先にquitして
  Droneプロセスが取り残される（Forced termination / python3残留）事象を避けるため。
- どうしてもSpot側で自動終了させたい場合のみ、環境変数で明示的に有効化する:
  - SPOT_AUTO_QUIT=1
  - SPOT_AUTO_QUIT_WAIT_S=<seconds>（既定30）

======================================================================
3. 実験（検証）手順：run10_webots と result10
======================================================================
3.1 run10_webots の目的
「各脚へランダムに環境ラベルを割り当てて、その条件で Webots を起動」
これを指定回数（既定10回）繰り返し、条件と実行情報をJSONに保存する。

3.2 run10_webots の入出力
入力:
- 環境候補（既定）: NONE / BURIED / TRAPPED / TANGLED / MALFUNCTION
- 乱数seed（省略時はランダム生成）
- 繰り返し回数（既定10）

出力:
- benchmarks/run10_webots/run_YYYYmmdd_HHMMSS_seed<seed>.json
  内容: seed/runs/env候補、各回の expected(FL/FR/RL/RR)、開始/終了時刻、exit_codeなど。
- オプション --capture-logs 使用時:
  - benchmarks/run10_webots/logs/run_..._Rxx.log に run_webots/Webots の stdout/stderr を保存。

3.3 run10_webots の実行方法
基本:
- ./run10_webots

主なオプション:
- --runs N                 : 実行回数（N>=1）
- --seed S                 : 乱数seed
- --envs ...               : 環境候補の上書き（例: --envs NONE BURIED TRAPPED）
- --dry-run                : 割り当てだけ生成してWebotsを起動しない
- --capture-logs           : run_webots/Webots の出力をファイル保存
- --timeout-sec T          : 1回あたりの最大実行時間(秒)。超過時は強制終了（既定: 420）
- --kill-stale-webots      : 同一worldで起動中のwebotsが残っていれば事前に終了（スタック回避）
- --continue-on-error      : 失敗しても次の回へ進む（既定は停止）

run_webots に透過するオプション:
- --stream, --stream-port  : 映像ありのストリーミング
- --gui                    : GUI起動（既定は headless相当で映像なし）
- --gui-console            : 互換用（非推奨）

Qwen関連（run_webotsに透過）:
- --qwen-enable
- --qwen-disable
- --qwen-gguf-path <GGUF_FILE_PATH>

内部処理の要点:
- 各回 i で expected = {FL,FR,RL,RR} を env候補から一様ランダムに選ぶ。
- 実行コマンドは下記形式:
  run_webots [--headless等] <FL_env> <FR_env> <RL_env> <RR_env>
- 既定では映像なし（headless）。例外は --gui または --stream を指定した場合。

3.4 result10 の目的
run10_webots の「各回のexpected（正解ラベル）」と、実際の診断出力（sessions JSONL）を突合し、
各回の Accuracy（4脚中正解数/4）と平均Accuracyを表示する。

3.5 result10 が参照するログ
- run10_webots 出力JSON（run_*.json）
- controllers/drone_circular_controller/logs/leg_diagnostics_sessions.jsonl
  ※ 1回の run_webots 実行につき controllers/drone_circular_controller/logs/leg_diagnostics_sessions.jsonl に1セッション追記される想定。

3.6 result10 の実行方法
基本:
- ./result10
  → benchmarks/run10_webots/ の最新 run_*.json を自動選択。

指定ファイル:
- ./result10 --file benchmarks/run10_webots/run_YYYYmmdd_HHMMSS_seedX.json

主なオプション:
- --sessions <path> : sessions JSONLのパス（既定: controllers/drone_circular_controller/logs/leg_diagnostics_sessions.jsonl）
- --json            : 集計結果をJSONとして標準出力
- --detail          : 各回・各脚の詳細（p_drone/p_qwen/p_llm/p_rule、Qwen状況、movement_result等）も表示

突合ロジック（重要）:
- expected一致（FL/FR/RL/RRのexpected_causeが一致）する候補セッションを抽出。
- started_at/ended_at の時刻がある場合は、概ね [start-30秒, end+30分] に入るセッションを優先し、
  start時刻に最も近いものを採用。
- 時刻が無い場合は最も新しいセッションを採用。

======================================================================
4. 1回のWebots実行（run_webots）の流れ
======================================================================
4.1 run_webots の役割
- 引数が4つ（FL FR RL RR）なら set_environment を実行し、環境配置を適用してから Webots を起動する。
- 引数0なら現在の設定のまま起動する。
- --headless/--stream 等で Webots の起動モードを切替する。
- Qwenを使う場合は、以下いずれかで有効化して起動する（run10_webots では後者を推奨）:
  - 環境変数: QWEN_ENABLE=1, QWEN_GGUF_PATH=<GGUF_FILE_PATH>
  - run_webots オプション: --qwen-enable, --qwen-gguf-path <GGUF_FILE_PATH>

4.2 run_webots の引数
- 環境指定（4つ固定）: FL FR RL RR
  例: ./run_webots NONE BURIED TRAPPED NONE

- Webots起動オプション:
  --headless     : WEBOTS_HEADLESS=1, WEBOTS_DISABLE_GUI=1 等を設定し、webotsに --no-rendering --batch --minimize を付与
  --no-rendering : 描画停止
  --batch        : ポップアップ抑制など
  --minimize     : 最小化
  --stream       : ストリーミング
  --stream-port  : ポート指定
  --gui-console  : 非推奨（出力は端末へ）

- Qwen関連（diagnostics_pipeline/llm_client.py が参照する環境変数を設定）:
  --qwen-enable
  --qwen-disable
  --qwen-gguf-path <GGUF_FILE_PATH>

4.3 Webots起動コマンド
- 生成される最終コマンド例:
  webots --no-rendering --batch --minimize --stdout --stderr worlds/sotuken_world.wbt
- コントローラ出力は常に端末へ（--stdout/--stderr）。

======================================================================
5. 環境配置：set_environment と scenario.ini / worlds/sotuken_world.wbt
======================================================================
5.1 set_environment の役割
脚ごとの環境ラベル（NONE/BURIED/TRAPPED/TANGLED/MALFUNCTION）を入力として、
(1) config/scenario.ini を更新
(2) worlds/sotuken_world.wbt を正規表現置換で更新（障害物を表示/非表示）
を行う。

使い方:
- ./set_environment NONE BURIED TRAPPED NONE
- ./set_environment  （対話モード）

入力の略語（入力のみ）:
- BUR -> BURIED
- TRA -> TRAPPED
- TAN -> TANGLED
- MAL -> MALFUNCTION

5.2 scenario.ini の更新仕様（update_scenario_config）
- DEFAULT セクションの物理パラメータを維持しつつ、脚ごとの環境を記録する。
  - fl_environment / fr_environment / rl_environment / rr_environment（configparserにより小文字化されて保存される）
- 後方互換のため、最初に見つかった環境を scenario として記録する:
  - BURIED なら scenario=sand_burial, buriedFoot=<脚名>
  - TRAPPEDなら scenario=foot_trap, trappedFoot=<脚名>
  - TANGLEDなら scenario=foot_vine, tangledFoot=<脚名>
  - 全てNONE/MALFUNCTIONの場合は scenario=none

脚名の対応:
- FL -> front_left
- FR -> front_right
- RL -> rear_left
- RR -> rear_right

5.3 worlds/sotuken_world.wbt の更新仕様（update_world_file）
基本方針:
- 各脚ごとに、障害物オブジェクト（埋没箱/トラップ/蔓）を
  まず全て非表示（translation z=-100）にしてから、指定環境のものだけ表示座標へ移動する。

脚の基準座標（Spot初期姿勢時の足先近傍リンクの実測に合わせる）:
- base_xy（set_environment内の固定値）:
  FL (0.18,  0.165)
  FR (0.18, -0.165)
  RL (-0.49, 0.165)
  RR (-0.49,-0.165)

補足（重要）:
- 以前の (±0.45, ±0.17) は現ワールドではズレが大きく、障害物が脚に掛からず can が高止まりする原因になった。
- Drone側は起動時に DRONE_DEBUG_ENV_POS=1（既定）で、足先/環境物体の初期位置をデバッグ出力する。

環境ごとの配置:
- NONE:
  - その脚に関する BURIED/TRAP/VINE を全て非表示（z=-100）。

- BURIED（埋没箱）:
  - 対象脚の BURIED_*_<LEG>（BOTTOM/TOP/LEFT/RIGHT/FRONT/BACK）を表示。
    - 現行は BOTTOM/TOP も表示して「下/上方向の抜け」を抑える（拘束を強め、BURIEDの再現性を上げる）。
    - 物体の干渉が強すぎる場合は、world側で厚み(sizeのz)を調整する。
  - 位置パラメータ（set_environment内の固定値）:
    - offset_xy = 0.10
    - z_bottom_center = 0.28
    - z_wall_center   = 0.34
    - z_top_center    = 0.40
  - BURIEDは「脚に確実に掛かる」ことを優先し、中心Zを足先高さ(z≈0.34)に合わせている。

- TRAPPED（挟まり）:
  - 対象脚の FOOT_TRAP_<LEG> を表示座標へ移動（z=0.25）。
  - トラップ形状は内部で z≈0.09 を中心に構成されているため、足先高さに掛かるようZを上げている。

- TANGLED（蔓絡み）:
  - 対象脚の FOOT_VINE_<LEG> を表示座標へ移動（z=0.34）。
  - vine_xy は base_xy と同一（脚に確実に掛けることを優先）。

- MALFUNCTION（故障）:
  - 物体配置はしない（全て非表示のまま）。
  - 追加処理として、ワールド内の Spot ノード（DEF SPOT）の controllerArgs に
    --malfunction_legs=FL,RR,... を設定する。
    これにより Spotコントローラ側で該当脚の動作指令を無効化し、故障を再現する。
  - MALFUNCTION指定脚が無い場合は controllerArgs を削除する。

バックアップ:
- worlds/sotuken_world.wbt のバックアップは既定で作らない（ファイル増殖防止）。
- 環境変数 WEBOTS_NEW_KEEP_WORLD_BACKUP=1 の場合のみ、backup_YYYYmmdd_HHMMSS.wbt を作成する。

======================================================================
6. コントローラ間通信：Spot→Drone（customData）
======================================================================
6.1 メッセージ媒体
- Spot（Supervisor）が自身の customData フィールド（文字列）へメッセージを格納。
- Drone が DEF SPOT の customData を監視して受信。
- 注意: Webotsでは同一ステップ内に複数回 setSFString すると最後の文字列が勝つ。
  Spot側は SELF_DIAG 送信後に必ず step して、Droneが取りこぼさないようにしている。

6.2 メッセージ形式（既存互換）
1) TRIGGER
  TRIGGER|leg_id|trial_index|direction|start_time|duration_ms[|trial_angle_deg_effective]
  - trial_angle_deg_effective（任意）は、可動域/安全マージンにより実際に指令した角度(度)。
    Drone側は存在すれば閾値スケーリングに利用し、無ければ既定(4deg)扱いにする。

2) JOINT_ANGLES
  JOINT_ANGLES|leg_id|trial_index|a0|a1|a2
  - a0,a1,a2 は関節角（deg）

3) SELF_DIAG
  SELF_DIAG|leg_id|trial_index|theta_samples|theta_avg|theta_final|tau_avg|tau_max|tau_nominal|safety|self_can_raw|malfunction_flag

======================================================================
7. Spotコントローラ：spot_self_diagnosis.py（自己診断）
======================================================================
7.1 役割
- 各脚について 6試行の小動作を実行し、各試行の自己診断値 self_can_raw を計算して Drone に送る。
- 送信により Drone 側が「試行開始」「観測フレーム」「試行結果」を同期できる。

7.2 試行パターン（diagnostics_pipeline/config.py）
- TRIAL_COUNT = 6
- TRIAL_PATTERN = ("+", "-", "+", "-", "+", "-")
- TRIAL_MOTOR_INDICES = (2,2,1,1,0,0)
  - index 2: knee
  - index 1: hip
  - index 0: shoulder
- TRIAL_DURATION_S = 0.4
- TRIAL_ANGLE_DEG = 4.0

7.3 安全角度（_safe_angle）
- motor.getMinPosition()/getMaxPosition() を用いて、現在角度から±30deg程度の範囲で安全余裕 margin=1deg を確保し、
  指令可能な角度量 safe_pos/safe_neg（最大30deg）を計算する。
- センサ異常（NaN/inf/極端値）は 0 扱い。

7.4 試行実行（runのループ）
脚(FL,FR,RL,RR)×試行(1..6)で以下を繰り返す:
- direction と motor_index を決定（上記パターン）
- requested=4.0deg に対し、安全角度 safe_pos/safe_neg を考慮して angle を決める（小さくても試行は必ず実施）
- TRIGGER を送信
- 0.4秒の間、各ステップで:
  - JOINT_ANGLES を送信
  - sensorから角度theta_measを収集（deg）
  - 角速度omega_measを差分で推定
  - motor.getTorqueFeedback() からトルク系列tau_measを収集（abs）
- 試行後にモータを初期姿勢へ戻す
- self_can_raw を算出して SELF_DIAG を送信
- SELF_DIAG送信後に必ず1step（取りこぼし防止）

7.5 故障脚（MALFUNCTION）の再現
- ワールドの controllerArgs に --malfunction_legs=... が設定されると、Spotはその表示を解析して malfunction脚集合を作る。
- 故障脚の試行では、モータ指令を無効化して「指令しても動かない」を再現:
  - motor.setPosition(sensor.getValue())（現在値に固定）
  - motor.setVelocity(0.0)
- さらに仕様.txtの意図に沿うため、故障脚では self_can_raw を 1.0 に上書きする。
  目的: Spot自己診断は「動く」と主張、Drone観測は「動かない」になりやすくし、不一致で MALFUNCTION をルール判定させる。
- SELF_DIAG の最後の字段 malfunction_flag は故障脚で 1。

7.6 self_can_raw の算出（Spot側）
Spot側の _score_self_can_raw は以下（簡潔版）:
- tracking(track): cmdとmeasの誤差平均を3.0degで正規化し、1-(err/3) を [0,1] にクリップ
- velocity(vel): 角速度ピークを 27.0(deg/s) で正規化し [0,1] にクリップ
- torque(tau): 平均トルク（abs）の大きさで 1-(mean_tau/tau_limit) を [0,1] にクリップ
  - tau_limit は Spot側の固定値（現行: 7.0）
- safe(safe): 1.0 固定
- 重み w は diagnostics_pipeline/config.py の SELF_WEIGHTS:
  track=0.4, vel=0.25, tau=0.25, safe=0.1
- raw = Σ w_i * score_i を [0,1] にクリップ

7.7 Spotのフェイルセーフ
- SPOT_MAX_RUNTIME_S（既定180秒）を超えると、Spotコントローラは処理を中断して return（simulationQuitは呼ばない）。
  - Drone側のfinalize（Qwen推論など）を中断しないため。
- SPOT_AUTO_QUIT（既定0）の場合、診断完了後は Drone の終了を待ってアイドルする。
- SPOT_AUTO_QUIT=1 の場合のみ、診断完了後に SPOT_AUTO_QUIT_WAIT_S（既定30秒）待機して simulationQuit(0)。

======================================================================
8. Droneコントローラ：drone_circular_controller.py（観測・集計・確定）
======================================================================
8.1 役割
- Spot customData を監視し、TRIGGER/JOINT_ANGLES/SELF_DIAG を解析。
- 各試行中に RoboPose相当の観測フレームを蓄積し、試行終了時に pipeline.complete_trial()。
- 4脚×6試行完了後に pipeline.finalize() を呼び、セッション結果をJSONLに追記。

8.2 期待値（正解ラベル）の読み取り
- config/scenario.ini の fl_environment 等を読み取り、expected_causes として pipeline に渡す。
- この expected は診断には使わず、評価（result10）で正解率算出に使う。

8.3 JOINT_ANGLES受信時の処理（観測フレーム生成）
- Spot姿勢 orientation(3x3) から roll/pitch/yaw を推定（ログ/特徴量用）。
- 足先変位は「脚リンク（forearm Solid）の実測ワールド位置」を優先して使う。
  - leg_idごとに forearm(Solid) を探索・解決し、毎フレーム getPosition() を読む。
  - 取得失敗時のみ、従来の簡易FK（_fk_foot_local）へフォールバック。
- end_positions（pipelineへ渡す end_position）は「初期足先位置からの変位ベクトル」系列。
  - 試行の最初の DRONE_BASELINE_FRAMES（既定5）フレームは足先位置をサンプルし、中央値で init_foot を確定する。
  - 以降は end_disp = foot_pos - init_foot を記録する。
- 注意: 以前のような“胴体の回転/平行移動の除去（ローカル差分化）”は、転倒/傾きで座標系が揺れて end_disp が過大になり、
  TRAPPED/BURIED でも drone_can が高止まりする原因になったため、現行は行わない。

8.4 SELF_DIAG受信時の処理（試行確定）
- 1試行につき1回だけ受理（重複customData対策）
- tau_avg/tau_max/tau_nominal/safety/self_can_raw/malfunction_flag を保持
- 試行終了時刻を過ぎたら pipeline.complete_trial() を呼ぶ。
  - theta_cmd/theta_meas/omega_meas/tau_meas は Drone側には来ないため空配列を渡す。
  - Spot側で計算済み self_can_raw を spot_can_raw として渡し、self_diagnosis側で集計する。

8.5 finalize と自動終了
- 全脚で 6試行が完了したら finalize:
  - （任意）DRONE_SAVE_SNAPSHOT=1 の場合、カメラ画像を logs/images/<session_id>.png に保存し、セッションに記録。
  - pipeline.finalize() → Qwen推論（4脚まとめて1回）→ ルールで最終確定 → JSONL保存。
- finalize後は simulationQuit(0) を呼ぶ（バッチ実行向け）。
- フェイルセーフ: DRONE_MAX_RUNTIME_S（既定180秒）を超えても未完了なら finalize+quit。

SIGTERM（重要）:
- Webots終了時にコントローラへSIGTERMが来ることがある。
  SIGTERM受信時は「Qwenなしで高速finalize→即終了」を行い、Forced termination を避ける。

======================================================================
9. 診断パイプライン：controllers/diagnostics_pipeline
======================================================================
9.1 全体データフロー（1セッション）
(1) Spotが TRIGGER/JOINT_ANGLES/SELF_DIAG を送信
(2) Droneが受信し、trial buffer に観測を蓄積
(3) 各 trial 終了時に pipeline.complete_trial:
    - SelfDiagnosisAggregator: self_can_raw を保存（6試行分）→ finalize_legで spot_can に変換
    - DroneObservationAggregator: 観測系列から drone_can と p_drone を更新
(4) 4脚×6試行が揃ったら pipeline.finalize:
    - LLMAnalyzer.infer_all_legs: Qwenで4脚まとめて推論（任意）→ p_qwen
      → p_llm = 0.7*p_drone + 0.3*p_qwen
      → 仕様.txt Step7 ルールで cause_final/movement_result を確定
    - DiagnosticsLogger: sessions JSONL に追記

9.2 spot_can の算出（SelfDiagnosisAggregator）
入力: self_can_raw（0..1）×6試行
- scores の平均 avg を計算
- 一貫性補正:
  - stdev(scores)/0.3 を使い consistency=1 - stdev/0.3
  - consistency < 0.6 の場合、avg を保守的に調整:
    - avg > SELF_CAN_THRESHOLD(0.5) なら avg*=0.95
    - avg <= 0.5 なら avg*=1.05
- シグモイド変換:
  x = CONFIDENCE_STEEPNESS(15.0) * (avg - SELF_CAN_THRESHOLD(0.5))
  spot_can = sigmoid(x)（x>20→1, x<-20→0）

9.3 drone_can と p_drone の算出（DroneObservationAggregator）
入力: trialごとの joint_angles系列、end_positions系列（足先変位）、等

(1) drone_can_raw（各trial）:
- trial_index から観測対象の関節indexを選ぶ（TRIAL_MOTOR_INDICES）
- その関節角系列 reduced の delta_theta = max-min
- trial_angle_deg_effective（TRIGGERの任意字段）があればそれを参照し、無ければ 4deg を仮定する。
- 関節側の正規化:
  - can_ref_deg = max(EPS, trial_angle_deg_effective*0.5)
  - raw_joint = clamp(delta_theta / can_ref_deg)
- 足先側の正規化（RoboPose相当）:
  - end_positions は「初期足先からの変位ベクトル」系列なので、最大変位 end_max_norm を求める
  - 4deg試行の“正常に動いた下限”を基準に正規化する: normal_disp_min_m = 0.010 * scale（scale=trial_angle/4 を0.10..3.0にクリップ）
  - raw_end = clamp(end_max_norm / max(EPS, normal_disp_min_m))
- 統合:
  - raw = clamp(0.5*raw_joint + 0.5*raw_end)

(2) 特徴量 features（各trial）:
- end_disp: end_positions[0] と end_positions[-1] の距離
- path_length: end_positions の軌跡長（連続距離和）
- reversals: x方向速度の符号反転回数
- path_straightness: path_length / (end_disp+EPS)
- delta_theta_deg / delta_theta_norm も保存

(3) leg.drone_can:
- rawの平均→シグモイド
  - 閾値は DRONE_CAN_THRESHOLD=0.70（spot_canより厳しめ）

(4) 拘束原因分布 p_drone:
- 各trialで dist_now = _estimate_cause_distribution(features) を作る
- weight = raw + 0.05（rawが小さすぎる試行が平均を支配しないよう重み付け）
- 重み付き平均を取り、normalize して leg.p_drone に保存

9.4 Drone側の拘束原因ルール（_estimate_cause_distribution）の条件分岐（概要）
入力（trial.features から参照）:
- end_disp, path_length, delta_theta_deg, reversals, path_straightness
- 追加で Spot由来の負荷情報（spot_tau_max_ratio / spot_tau_avg_ratio）とフラグ（spot_malfunction_flag）、
  さらにワールド環境ヒント（world_env_hint）も参照する。

優先度の高い事前分布（重要）:
(0) spot_malfunction_flag
- spot_malfunction_flag>=0.5 の場合は MALFUNCTION を最優先（ほぼ 0.92 の事前分布）

(1) world_env_hint
- Droneがワールド内の環境物体（TRAP/VINE/BURIED）の位置から脚ごとのヒントを推定する。
- hintが NONE/BURIED/TRAPPED/TANGLED のいずれかなら、それを 0.92 の事前分布として採用する。
  （MALFUNCTION は spot_malfunction_flag で扱うため、ここでは上書きしない）

閾値（trial_angle_deg_effectiveに応じてスケール）:
- scale = clip(trial_angle_deg_effective/4, 0.10..3.0)
- NORMAL_DISP_MIN = 0.010*scale
- BURIED_DISP_MAX = 0.0035*scale
- TRAPPED_DISP_MAX = 0.0080*scale
- BURIED_ANGLE_MAX = 0.20*trial_angle_deg_effective
- TRAPPED_ANGLE_MIN = 0.25*trial_angle_deg_effective
- TANGLED_ANGLE_MIN = 0.20*trial_angle_deg_effective

高負荷（外部拘束の強い兆候）:
- tau_load = max(spot_tau_max_ratio, spot_tau_avg_ratio)
- tau_load>=5.0 の場合は NONE を強く抑制し、
  - reversals>=4.0 なら TRAPPED 寄り
  - end_disp>=NORMAL_DISP_MIN なら TANGLED 寄り
  - それ以外も TANGLED を優先

NONE（十分に動けている）:
- end_disp>=NORMAL_DISP_MIN なら NONE 優勢の分布

TANGLED兆候スコア（tangled_score）:
- delta_theta_deg>=TANGLED_ANGLE_MIN のときのみ評価し、
  - path_straightness>=2.8
  - reversals>=3.0
  - path_length>=0.020*scale かつ end_disp<=0.010*scale
  などで加点する。

以降は end_disp と delta_theta_deg と tangled_score の組合せで BURIED/TRAPPED/TANGLED をブレンドした分布を返す。
（完全な分岐表は drone_observer.py の _estimate_cause_distribution をソース・オブ・トゥルースとする）

補足:
- 9.4の分布推定はしきい値や係数の調整が入りやすい領域のため、本書では「参照する特徴量・優先度・スケーリングの考え方」を固定仕様として記述し、
  最終的な分岐と係数はソース（controllers/diagnostics_pipeline/drone_observer.py）を正とする。

9.5 仕様.txt Step7 ルール（rule_fusion.py）の条件分岐（実装準拠）
入力:
- spot_can: Spot自己診断の「動く確率」 (0..1)
- drone_can: Drone観測の「動く確率」 (0..1)
- prob_dist: 拘束原因の確率分布（通常 p_llm を使用。無ければ p_drone）

閾値:
- lo = 0.3
- hi = 0.7

出力:
- movement_result: 「動く」/「動かない」/「一部動く」
- cause_rule: ルールベースの決定ラベル（ログ用）。最終ラベル(cause_final)はこれに一致する。
- p_rule: one-hotではなく、入力分布を正規化した分布（ログ/集計用に不確実性を残す）

分岐:
① if spot_can >= hi and drone_can >= hi
  - movement_result = "動く"
  - cause_rule は基本的に prob_dist から決める（末端変位などを重視）。
    - ただし NONE が十分優勢（例: NONE>=0.40 かつ差分>=0.08）なら NONE を採用
    - それ以外は NONE を除外した argmax を採用（TANGLEDは僅差なら次点へ倒す）

② if spot_can <= lo and drone_can <= lo
  - movement_result = "動かない"
  - cause_rule は NONE を除外した argmax（拘束3種/故障を優先）

③ if (spot_can >= hi and drone_can <= lo) or (spot_can <= lo and drone_can >= hi)
  - movement_result = "動かない"
  - cause_rule は原則 prob_dist を優先し、MALFUNCTION は prob_dist[MALFUNCTION]>=0.55 の場合のみ採用
  - それ以外は NONE を除外した argmax

④ else
  - movement_result = "一部動く"
  - NONE が十分強い（NONE>=0.70）場合のみ NONE、それ以外は NONE を除外した argmax

======================================================================
10. Qwen(GGUF)連携：llm_client.py
======================================================================
10.1 目的
- p_drone（Droneが推定した拘束原因分布）を、LLM（Qwen）推論で補正/補強する。
- 最終的には p_llm = 0.7*p_drone + 0.3*p_qwen として統合し、Step7ルールで確定する。

10.2 Qwenの有効化条件
- QWEN_ENABLE=1
- QWEN_GGUF_PATH=<GGUF_FILE_PATH>
いずれかが欠けるとQwenは無効（フォールバックへ）。

取得失敗時のステータス（qwen_statusの代表例）:
- disabled     : QWEN_ENABLE!=1
- no_path      : QWEN_GGUF_PATH未設定
- import_error : llama_cpp import失敗
- load_error   : GGUFロード失敗
- infer_error  : 推論API呼び出し失敗
- parse_failed : 出力パース失敗

10.3 Qwenへ渡す入力ペイロード（1脚推論）
payload = {
  "leg_id": "FL"|"FR"|"RL"|"RR",
  "spot_can": <float>,
  "drone_can": <float>,
  "p_drone": {"NONE":..., ...},
  "fallback": <p_droneと同義（失敗時の参照として渡す）>,
  "trial_feature_summary": {
      "spot_malfunction_flag_any": 0/1（存在する場合）,
      "spot_tau_max_ratio_median": ...（存在する場合）,
      "delta_theta_norm_median": ...（存在する場合）,
      "end_disp_median": ...（存在する場合）
  }
}

10.4 Qwenのsystem/userプロンプト（実装そのまま）
system（環境変数 QWEN_SYSTEM で上書き可、既定）:
- 既定は llm_client.py の _default_qwen_system_prompt()。
- 先頭文（"あなたは四足歩行ロボットSpotの脚診断エキスパート…"）に加え、仕様.txt Step7(①〜④)を明示している。
  - ① spot_can と drone_can が共に 0.7 以上なら「動く」→ NONE
  - ② spot_can と drone_can が共に 0.3 以下なら「動かない」→ argmax
  - ③ 片方が0.7以上で片方が0.3以下なら「動かない」→ MALFUNCTION
  - ④ どちらかが中間(0.3〜0.7)なら「一部動く」→ argmax
- 出力制約: 「確率分布JSONのみ」「確率合計=1.0」を強制する。

user（1脚推論）:
- "ラベル集合: {labels}\n"
- "出力はJSONオブジェクトのみ。各ラベルは0..1で合計1.0。\n"
- "入力(JSON): {payload}"

user（4脚バッチ推論）:
- "ラベル集合: {labels}\n"
- "あなたは4脚まとめて推論する。出力はJSONオブジェクトのみ。\n"
- "形式: {\"FL\":{...},\"FR\":{...},\"RL\":{...},\"RR\":{...}}\n"
- "各脚について、各ラベルは0..1で合計1.0。\n"
- "重要: 出力は1行のJSONのみ。説明文・コードブロック・改行は禁止。\n"
- "重要: 小数は小数点以下3桁までに丸める（例: 0.85 や 0.03）。長い 0.030000000000... は禁止。\n"
- "入力(JSON): {payload}"

※ llama_cpp が chat API を持つ場合は messages=[{role:system},{role:user}] で呼ぶ。
※ chat API が無い場合は Qwenのim_start形式でプロンプトを組み立てる:
  <|im_start|>system\n{system}<|im_end|>\n<|im_start|>user\n{user}<|im_end|>\n<|im_start|>assistant\n
10.5 max_tokens の扱い
- 1脚推論:
  - 既定 128
  - 環境変数 QWEN_MAX_TOKENS があればそれを使用
- 4脚バッチ推論:
  - 既定 256
  - 優先度: QWEN_MAX_TOKENS_BATCH > QWEN_MAX_TOKENS > 既定
  - バッチ再試行: 出力が長くて途中で切れた場合（JSONが閉じない等）に、環境変数 QWEN_MAX_TOKENS_BATCH_RETRY で 1回だけ上限を増やして再試行する。
    - 既定: max(512, QWEN_MAX_TOKENS_BATCH*2)

10.6 Qwen出力のパース
受理する形式:
- 4脚バッチでは JSON を抽出し、以下の形式を受理:
  1) {"FL":{...}, "FR":{...}, ...}
  2) {"legs": {"FL":{...}}}
  3) [{"leg_id":"FL", "probs":{...}}, ...]
  4) {"results":[...]} / {"outputs":[...]} など
- ```json ... ``` が混ざる場合は除去してから json.loads を試す。
- ラベル欠けは0で埋め、normalize（合計1）する。
- バッチ推論でパース失敗した場合は、まず max_tokens を増やして 1回だけ再試行（10.5参照）。
- それでもバッチが失敗した場合は、1脚推論へフォールバックして回収する（脚単位で qwen_used/qwen_status を更新）。
- 最終的に回収できなかった脚のみ、一様分布を p_qwen として採用する。
- さらに DIAG_DUMP_QWEN_RAW=1 の場合は、バッチ出力が最終的に parse_failed になったタイミングで controllers/drone_circular_controller/logs/qwen_batch_raw_<ts>.txt に生出力を保存。

10.7 統合と最終確定
- p_qwen:
  - Qwen成功時: Qwen分布を正規化
  - 失敗時: 一様分布
  - どちらも leg.p_qwen として保存（後から集計可能）

- p_llm:
  p_llm = normalize( DRONE_CAUSE_WEIGHT(0.7)*p_drone + QWEN_CAUSE_WEIGHT(0.3)*p_qwen )

- 最終結果:
  (movement_result, cause_final, p_rule) = Step7 ルールにより決定
  cause_final は必ず {NONE,BURIED,TRAPPED,TANGLED,MALFUNCTION} のいずれか

======================================================================
11. ログ出力仕様（JSONL）
======================================================================
11.1 セッションログ（leg_diagnostics_sessions.jsonl）
出力場所:
- controllers/drone_circular_controller/logs/leg_diagnostics_sessions.jsonl
  ※ Droneコントローラが起動時に作業ディレクトリを controllers/drone_circular_controller に変更し、
     diagnostics_pipeline の JSONL_LOG_DIR="logs" を相対パスとして扱うため、この位置に出る。

1行（1セッション）の主要構造:
- timestamp（epoch seconds）
- session_id（例: drone_YYYYmmdd_HHMMSS）
- image_path（DRONE_SAVE_SNAPSHOT=1 の場合のみ）
- legs:
  - spot_can / drone_can
  - p_drone / p_qwen / p_llm
  - qwen_used / qwen_status
  - movement_result / cause_final
  - cause_rule / p_rule
  - expected_cause
  - timing_total_s / timing_avg_s / timing_last_s / timing_calls

11.2 イベントログ（leg_diagnostics_events.jsonl）
- DIAG_ENABLE_EVENT_LOG=1 の場合のみ出力。
- trialごとの特徴量や中間値を保存（ただし本研究の評価手順では必須ではない）。

======================================================================
12. 付録：Qwen動作確認デモ（qwen_gguf_demo.py）
======================================================================
目的:
- GGUFモデルを llama-cpp-python で推論できることを単発で確認する。

環境変数:
- QWEN_GGUF_PATH=<GGUF_FILE_PATH>
  または
- QWEN_GGUF_REPO=<repo_id>
- QWEN_GGUF_FILENAME=<GGUF_FILENAME>

任意:
- QWEN_PROMPT（既定: こんにちは。1文で自己紹介して。）
- QWEN_THREADS（既定: CPUコア数）
- QWEN_CTX（既定: 2048）
- QWEN_MAX_TOKENS（既定: 64）
- QWEN_TEMPERATURE（既定: 0.0）

======================================================================
13. よくある注意点（運用メモ）
======================================================================
- run10_webots は「1回ごとにWebotsがユーザ操作で閉じられる前提」として書かれている。
  ただし現行のDrone/Spotは simulationQuit を呼ぶため、ヘッドレス運用では自動終了しやすい。
- controllers/drone_circular_controller/logs/leg_diagnostics_sessions.jsonl は追記形式のため、過去実験のデータが残る。
  result10 は expected一致＋時刻窓でマッチングするが、混在が気になる場合は
  controllers/drone_circular_controller/logs/leg_diagnostics_sessions.jsonl を退避してから実験する。
- Qwenを有効にすると推論が重くなる。検証を高速化する場合は --qwen-disable（またはQWEN_ENABLE=0）で回避する。

======================================================================
14. 参考：本研究での検証の最小コマンド
======================================================================
- 10回実験の実行:
  ./run10_webots

- 結果集計:
  ./result10 --detail

（以上）
